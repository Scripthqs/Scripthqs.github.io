(window.webpackJsonp=window.webpackJsonp||[]).push([[182],{650:function(s,e,a){"use strict";a.r(e);var r=a(50),t=Object(r.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"promise深入-自定义promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise深入-自定义promise"}},[s._v("#")]),s._v(" Promise深入 + 自定义Promise")]),s._v(" "),a("h2",{attrs:{id:"_1-准备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-准备"}},[s._v("#")]),s._v(" 1. 准备")]),s._v(" "),a("h3",{attrs:{id:"_1-1-函数对象与实例对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-函数对象与实例对象"}},[s._v("#")]),s._v(" 1.1. 函数对象与实例对象")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 函数对象: 将函数作为对象使用时, 简称为函数对象\n2. 实例对象: new 函数产生的对象, 简称为对象\n")])])]),a("h3",{attrs:{id:"_1-2-回调函数的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-回调函数的分类"}},[s._v("#")]),s._v(" 1.2. 回调函数的分类")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 同步回调: \n    理解: 立即执行, 完全执行完了才结束, 不会放入回调队列中\n    例子: 数组遍历相关的回调函数 / Promise的excutor函数\n2. 异步回调: \n    理解: 不会立即执行, 会放入回调队列中将来执行\n    例子: 定时器回调 / ajax回调 / Promise的成功|失败的回调\n")])])]),a("h3",{attrs:{id:"_1-3-js中的error"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-js中的error"}},[s._v("#")]),s._v(" 1.3. JS中的Error")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 错误的类型\n    Error: 所有错误的父类型\n    ReferenceError: 引用的变量不存在\n    TypeError: 数据类型不正确的错误\n    RangeError: 数据值不在其所允许的范围内\n    SyntaxError: 语法错误\n2. 错误处理\n    捕获错误: try ... catch\n    抛出错误: throw error\n3. 错误对象\n    message属性: 错误相关信息\n    stack属性: 函数调用栈记录信息\n")])])]),a("h2",{attrs:{id:"_2-promise的理解和使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise的理解和使用"}},[s._v("#")]),s._v(" 2. Promise的理解和使用")]),s._v(" "),a("h3",{attrs:{id:"_2-1-promise是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-promise是什么"}},[s._v("#")]),s._v(" 2.1. Promise是什么?")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1.抽象表达: \n    Promise是JS中进行异步编程的新的解决方案(旧的是谁?)\n2.具体表达:\n    从语法上来说: Promise是一个构造函数\n    从功能上来说: promise对象用来封装一个异步操作并可以获取其结果\n3. promise的状态改变(只有2种, 只能改变一次)\n    pending变为resolved\n    pending变为rejected\n4. promise的基本流程\n")])])]),a("p",[a("img",{attrs:{src:"http://vipkshttp1.wiz.cn/ks/share/resources/49c30824-dcdf-4bd0-af2a-708f490b44a1/92b8cbfb-a474-4859-943b-6048e9dc66f6/index_files/9b2b980e2959c4f996cafddb03fa5d4d.png",alt:"promise基本流程"}})]),s._v(" "),a("h3",{attrs:{id:"_2-2-为什么要用promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-为什么要用promise"}},[s._v("#")]),s._v(" 2.2. 为什么要用Promise?")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 指定回调函数的方式更加灵活: 可以在请求发出甚至结束后指定回调函数\n2. 支持链式调用, 可以解决回调地狱问题\n")])])]),a("h3",{attrs:{id:"_2-3-如何使用promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-如何使用promise"}},[s._v("#")]),s._v(" 2.3. 如何使用Promise?")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 主要API\n    Promise构造函数: Promise (excutor) {}\n    Promise.prototype.then方法: (onResolved, onRejected) => {}\n    Promise.prototype.catch方法: (onRejected) => {}\n    Promise.resolve方法: (value) => {}\n    Promise.reject方法: (reason) => {}\n    Promise.all方法: (promises) => {}\n    Promise.race方法: (promises) => {}\n2. 几个重要问题\n    如何改变promise的状态?\n    一个promise指定多个成功/失败回调函数, 都会调用吗?\n    promise.then()返回的新promise的结果状态由什么决定?\n    改变promise状态和指定回调函数谁先谁后?\n    promise如何串连多个操作任务?\n    promise异常传(穿)透?\n    中断promise链\n")])])]),a("h2",{attrs:{id:"_3-自定义promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-自定义promise"}},[s._v("#")]),s._v(" 3. 自定义Promise")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 定义整体结构\n2. Promise构造函数的实现\n3. promise.then()/catch()的实现\n4. Promise.resolve()/reject()的实现\n5. Promise.all/race()的实现\n6. Promise.resolveDelay()/rejectDelay()的实现\n7. ES6 class版本\n")])])]),a("h2",{attrs:{id:"_4-async与await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-async与await"}},[s._v("#")]),s._v(" 4. async与await")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. async 函数\n    函数的返回值为promise对象\n    promise对象的结果由async函数执行的返回值决定\n\n2. await 表达式\n    await右侧的表达式一般为promise对象, 但也可以是其它的值\n    如果表达式是promise对象, await返回的是promise成功的值\n    如果表达式是其它值, 直接将此值作为await的返回值\n\n3. 注意:\n    await必须写在async函数中, 但async函数中可以没有await\n    如果await的promise失败了, 就会抛出异常, 需要通过try...catch来捕获处理\n")])])]),a("h2",{attrs:{id:"_5-js异步之宏队列与微队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-js异步之宏队列与微队列"}},[s._v("#")]),s._v(" 5. JS异步之宏队列与微队列")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://vipkshttp1.wiz.cn/ks/share/resources/49c30824-dcdf-4bd0-af2a-708f490b44a1/92b8cbfb-a474-4859-943b-6048e9dc66f6/index_files/60b9ff398449db2dcfef9197e2187ae6.png",alt:"宏队列与微队列"}})]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("1. 宏列队: 用来保存待执行的宏任务(回调), 比如: 定时器回调/DOM事件回调/ajax回调\n2. 微列队: 用来保存待执行的微任务(回调), 比如: promise的回调/MutationObserver的回调\n3. JS执行时会区别这2个队列\n\tJS引擎首先必须先执行所有的初始化同步任务代码\n\t每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行\n")])])])])}),[],!1,null,null,null);e.default=t.exports}}]);