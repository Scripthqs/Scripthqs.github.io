(window.webpackJsonp=window.webpackJsonp||[]).push([[223],{691:function(_,v,t){"use strict";t.r(v);var a=t(50),i=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"函数高级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数高级"}},[_._v("#")]),_._v(" 函数高级")]),_._v(" "),t("h2",{attrs:{id:"_1、原型与原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、原型与原型链"}},[_._v("#")]),_._v(" 1、原型与原型链")]),_._v(" "),t("h3",{attrs:{id:"_1-1、原型-prototype"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、原型-prototype"}},[_._v("#")]),_._v(" 1.1、原型(prototype)")]),_._v(" "),t("ul",[t("li",[_._v("每个函数对象都有一个prototype属性，该属性默认对应一个"),t("code",[_._v("{}")]),_._v("(空对象)，称为原型对象。这个空对象"),t("code",[_._v("{}")]),_._v("是Object的实例对象。")]),_._v(" "),t("li",[_._v("原型对象都有一个constructor属性，指向函数对象。")])]),_._v(" "),t("p",[_._v("空对象表示没有我们自己添加的属性。")]),_._v(" "),t("p",[_._v("给原型对象添加属性（方法）===》实例对象可以访问。")]),_._v(" "),t("h3",{attrs:{id:"_1-2、显式原型和隐式原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、显式原型和隐式原型"}},[_._v("#")]),_._v(" 1.2、显式原型和隐式原型")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("每个函数对象都有一个prototype属性，称为显式原型属性，默认指向"),t("code",[_._v("{}")]),_._v("空实例对象。")])]),_._v(" "),t("li",[t("p",[_._v("每个实例对象都有一个__proto__属性，称为隐式原型属性。")])]),_._v(" "),t("li",[t("p",[_._v("构造函数对象的显示原型===实例对象的隐式原型")]),_._v(" "),t("ul",[t("li",[_._v("Function是new Function()产生的")]),_._v(" "),t("li",[_._v("Object也是new Function()产生的")])])]),_._v(" "),t("li",[t("p",[_._v("所有函数的__proto__都是一样的")])]),_._v(" "),t("li",[t("p",[_._v("函数的prototype属性：在定义函数时自动添加的，默认值是Object空对象。")])]),_._v(" "),t("li",[t("p",[_._v("对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值。")])]),_._v(" "),t("li",[t("p",[_._v("不要直接操作隐式原型(ES6之前)。")])])]),_._v(" "),t("h3",{attrs:{id:"_1-3、原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、原型链"}},[_._v("#")]),_._v(" 1.3、原型链")]),_._v(" "),t("ul",[t("li",[_._v("访问一个对象的属性，先在自身寻找，找到返回")]),_._v(" "),t("li",[_._v("找不到沿着__proto__这条链找，找到返回")]),_._v(" "),t("li",[_._v("最终没找到，返回undefined")]),_._v(" "),t("li",[_._v("原型链别名隐式原型链")])]),_._v(" "),t("p",[_._v("作用：查找对象属性（方法）")]),_._v(" "),t("h3",{attrs:{id:"_1-4、原型的继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、原型的继承"}},[_._v("#")]),_._v(" 1.4、原型的继承")]),_._v(" "),t("ul",[t("li",[_._v("构造函数的实例对象自动拥有构造函数原型对象的属性（方法）")]),_._v(" "),t("li",[_._v("原理：原型链")])]),_._v(" "),t("ol",[t("li",[_._v("所有函数的显示原型指向的对象是空Object实例对象(Object不满足)\n"),t("ul",[t("li",[t("code",[_._v("Object.prototype instanceof Object")]),_._v("//false")])])]),_._v(" "),t("li",[_._v("所有函数都是Function的实例，包括Function本身和Object\n"),t("ul",[t("li",[t("code",[_._v("Function.__proto===Function.prototype")])])])]),_._v(" "),t("li",[_._v("Object的原型对象是原型链的尽头\n"),t("ul",[t("li",[t("code",[_._v("object.prototype.__proto__")]),_._v("//null")])])])]),_._v(" "),t("h3",{attrs:{id:"_1-5、instanceof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5、instanceof"}},[_._v("#")]),_._v(" 1.5、instanceof")]),_._v(" "),t("ul",[t("li",[_._v("A instanceof B")]),_._v(" "),t("li",[_._v("如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false。")])]),_._v(" "),t("h2",{attrs:{id:"_2、回调函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、回调函数"}},[_._v("#")]),_._v(" 2、回调函数")]),_._v(" "),t("p",[_._v("什么是回调函数？")]),_._v(" "),t("ul",[t("li",[_._v("你定义的")]),_._v(" "),t("li",[_._v("你没有调用")]),_._v(" "),t("li",[_._v("但最终函数执行了")])]),_._v(" "),t("p",[_._v("常见的回调函数？")]),_._v(" "),t("ul",[t("li",[_._v("DOM事件的回调函数")]),_._v(" "),t("li",[_._v("定时器回调函数")]),_._v(" "),t("li",[_._v("Ajax请求回调函数")]),_._v(" "),t("li",[_._v("生命周期回调函数")])]),_._v(" "),t("h2",{attrs:{id:"_3、iife"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、iife"}},[_._v("#")]),_._v(" 3、IIFE")]),_._v(" "),t("p",[_._v("IIFE；Immediately-Invoked Function Expression（立即调用的函数表达式），也称为"),t("code",[_._v("匿名函数自调用")])]),_._v(" "),t("p",[_._v("使用IIFE的好处：")]),_._v(" "),t("ul",[t("li",[_._v("不必为函数命名，避免了污染全局变量")]),_._v(" "),t("li",[_._v("IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。")])]),_._v(" "),t("h2",{attrs:{id:"_4、this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、this"}},[_._v("#")]),_._v(" 4、this")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("fun()")]),_._v("this是window")]),_._v(" "),t("li",[t("code",[_._v("obj.fun()")]),_._v("this是obj")]),_._v(" "),t("li",[t("code",[_._v("var p = new test()")]),_._v("this是新建的对象p")]),_._v(" "),t("li",[t("code",[_._v("p.call(obj)")]),_._v("this是obj")])]),_._v(" "),t("h2",{attrs:{id:"_5、闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、闭包"}},[_._v("#")]),_._v(" 5、闭包")]),_._v(" "),t("p",[_._v("闭包产生的条件：")]),_._v(" "),t("ul",[t("li",[_._v("函数嵌套。")]),_._v(" "),t("li",[_._v("内部函数引用了外部函数的数据（变量/函数）")])]),_._v(" "),t("p",[_._v("通过chrome调试工具可以查看闭包")]),_._v(" "),t("ul",[t("li",[_._v("闭包是一种函数，闭包是一种现象。")])]),_._v(" "),t("h3",{attrs:{id:"_5-1、常见的闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1、常见的闭包"}},[_._v("#")]),_._v(" 5.1、常见的闭包")]),_._v(" "),t("ol",[t("li",[_._v("将一个函数作为另一个函数的返回值")]),_._v(" "),t("li",[_._v("将函数作为实参传递给另一个函数")])]),_._v(" "),t("h3",{attrs:{id:"_5-2、闭包的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2、闭包的作用"}},[_._v("#")]),_._v(" 5.2、闭包的作用")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("函数执行完后，延长变量的生命周期")])]),_._v(" "),t("li",[t("p",[_._v("让函数外部可以操作内部的数据变量")])]),_._v(" "),t("li",[t("p",[_._v("在函数执行完后，函数内部的局部变量一般不会存在，除了闭包中的变量。")])]),_._v(" "),t("li",[t("p",[_._v("函数外部不能访问函数内部的局部变量，但可以通过闭包让外部来操作内部的局部变量。")])])]),_._v(" "),t("h3",{attrs:{id:"_5-3、闭包的产生和死亡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3、闭包的产生和死亡"}},[_._v("#")]),_._v(" 5.3、闭包的产生和死亡")]),_._v(" "),t("ul",[t("li",[_._v("在嵌套内部函数时就产生了（不是调用）")]),_._v(" "),t("li",[_._v("在嵌套的内部函数成为垃圾对象时死亡 f=null")])]),_._v(" "),t("h3",{attrs:{id:"_5-4、闭包的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4、闭包的应用"}},[_._v("#")]),_._v(" 5.4、闭包的应用")]),_._v(" "),t("p",[_._v("定义JS模块")]),_._v(" "),t("ul",[t("li",[_._v("具有特定功能的JS文件")]),_._v(" "),t("li",[_._v("将所有数据和功能都封装到一个函数内部（私有的）")]),_._v(" "),t("li",[_._v("只向外暴露一个包含n个方法的对象和函数")]),_._v(" "),t("li",[_._v("模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能")])]),_._v(" "),t("p",[_._v("如何向外暴露方法：通过return 或者在函数内部添加window的方法")]),_._v(" "),t("h3",{attrs:{id:"_5-5、闭包的的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5、闭包的的缺点"}},[_._v("#")]),_._v(" 5.5、闭包的的缺点")]),_._v(" "),t("ul",[t("li",[_._v("函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。")]),_._v(" "),t("li",[_._v("要即使释放"),t("code",[_._v("f = null")])])]),_._v(" "),t("h3",{attrs:{id:"_5-6、内存溢出和内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-6、内存溢出和内存泄漏"}},[_._v("#")]),_._v(" 5.6、内存溢出和内存泄漏")]),_._v(" "),t("p",[_._v("内存溢出：")]),_._v(" "),t("ul",[t("li",[_._v("当程序运行所需的内存超过了剩余的内存，就会抛出内存溢出错误")])]),_._v(" "),t("p",[_._v("内存泄漏：")]),_._v(" "),t("ul",[t("li",[_._v("内存泄露指用不到（访问不到）的变量，依然占据这内存空间，不能被再次利用。")]),_._v(" "),t("li",[_._v("占用的内存没有及时释放")]),_._v(" "),t("li",[_._v("内存泄漏过多就会导致内存溢出")])]),_._v(" "),t("p",[_._v("常见的内存泄漏：")]),_._v(" "),t("ul",[t("li",[_._v("意外的全局变量")]),_._v(" "),t("li",[_._v("没有及时清理的计时器或回调函数")]),_._v(" "),t("li",[_._v("闭包不会导致内存泄漏也有说会")])])])}),[],!1,null,null,null);v.default=i.exports}}]);