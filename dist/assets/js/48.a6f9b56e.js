(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{504:function(t,e,v){"use strict";v.r(e);var _=v(21),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"react-组件化开发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-组件化开发"}},[t._v("#")]),t._v(" React 组件化开发")]),t._v(" "),v("p",[t._v("React 的组件相对于 Vue 更加灵活，可以按照不同的方式分成很多类组件")]),t._v(" "),v("ul",[v("li",[t._v("根据组件的定义方式，可以分为：函数组件(Function Component)和类组件(Class Component)")]),t._v(" "),v("li",[t._v("根据组件内部是否有状态需要维护，可以分为：无状态组件(Stateless Component)和有状态组件(Stateful Component)")]),t._v(" "),v("li",[t._v("根据组件的不同职责，可以分为：展示型组件(Presentation Component)和容器型组件(Container Component)")])]),t._v(" "),v("p",[t._v("不同组件的区别：")]),t._v(" "),v("ul",[v("li",[t._v("函数组件、无状态组件、展示型组件主要关注 UI 的展示")]),t._v(" "),v("li",[t._v("类组件、有状态组件、容器型组件主要关注数据逻辑")])]),t._v(" "),v("h2",{attrs:{id:"类组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[t._v("#")]),t._v(" 类组件")]),t._v(" "),v("p",[t._v("类组件的定义要求：")]),t._v(" "),v("ul",[v("li",[t._v("组件的名称是大写字符开头(包括类组件和函数组件)")]),t._v(" "),v("li",[t._v("类组件需要继承自 React.Component")]),t._v(" "),v("li",[t._v("类组件必须实现 render 函数")])]),t._v(" "),v("p",[t._v("在 ES6 之前，可以通过 create-react-class 模块来定义类组件，ES6 后官网建议使用 ES6 的 class 类")]),t._v(" "),v("ul",[v("li",[t._v("constructor 是可选的，通常在 constructor 中初始化一些数据")]),t._v(" "),v("li",[t._v("this.state 中维护的是组件内部的数据")]),t._v(" "),v("li",[t._v("render()方法是 class 组件唯一必须实现的方法")])]),t._v(" "),v("h2",{attrs:{id:"render-函数的返回值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#render-函数的返回值"}},[t._v("#")]),t._v(" render 函数的返回值")]),t._v(" "),v("p",[t._v("当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回一下类型之一：")]),t._v(" "),v("ol",[v("li",[t._v("React 元素\n"),v("ul",[v("li",[t._v("jsx：通过 jsx 编写的代码就会编译成 React.createElement，所以 jsx 是 React 元素")]),t._v(" "),v("li",[v("code",[t._v("<div/>")]),t._v("会被 React 渲染成 DOM 节点，"),v("code",[t._v("<MyComponent/>")]),t._v("会被 React 渲染成自定义组件")])])]),t._v(" "),v("li",[t._v("数组或 fragments\n"),v("ul",[v("li",[t._v("可以让 render 方法返回多个元素")])])]),t._v(" "),v("li",[t._v("Portals\n"),v("ul",[v("li",[t._v("可以渲染子节点到不同的 DOM 子树中")])])]),t._v(" "),v("li",[t._v("字符串或数值类型\n"),v("ul",[v("li",[t._v("在 DOM 中被渲染成文本节点")])])]),t._v(" "),v("li",[t._v("布尔类型或 null\n"),v("ul",[v("li",[t._v("什么都不渲染")])])])]),t._v(" "),v("h2",{attrs:{id:"函数组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数组件"}},[t._v("#")]),t._v(" 函数组件")]),t._v(" "),v("p",[t._v("函数组件使用 function 来定义函数，返回值和类组件 render 函数返回一致，函数组件有自己的特点")]),t._v(" "),v("ul",[v("li",[t._v("没有生命周期，也会被更新并挂载，但是没有生命周期函数")]),t._v(" "),v("li",[t._v("this 关键字不能指向组件实例(没有组件实例)")]),t._v(" "),v("li",[t._v("没有内部状态 state，有也无法维护")])]),t._v(" "),v("p",[t._v("之前函数组件只能做展示，不过有了 hooks 后就不一样了")])])}),[],!1,null,null,null);e.default=a.exports}}]);