(window.webpackJsonp=window.webpackJsonp||[]).push([[277],{748:function(_,v,t){"use strict";t.r(v);var a=t(21),i=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"函数、对象高级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数、对象高级"}},[_._v("#")]),_._v(" 函数、对象高级")]),_._v(" "),t("h2",{attrs:{id:"原型与原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型与原型链"}},[_._v("#")]),_._v(" 原型与原型链")]),_._v(" "),t("h3",{attrs:{id:"原型-prototype"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型-prototype"}},[_._v("#")]),_._v(" 原型(prototype)")]),_._v(" "),t("ul",[t("li",[_._v("每个函数对象都有一个 prototype 属性，该属性默认对应一个"),t("code",[_._v("{}")]),_._v("(空对象)，称为原型对象。这个空对象"),t("code",[_._v("{}")]),_._v("是 Object 的实例对象。")]),_._v(" "),t("li",[_._v("原型对象都有一个 constructor 属性，指向函数对象。")])]),_._v(" "),t("p",[_._v("空对象表示没有我们自己添加的属性。")]),_._v(" "),t("p",[_._v("给原型对象添加属性（方法）===》实例对象可以访问。")]),_._v(" "),t("h3",{attrs:{id:"显式原型和隐式原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#显式原型和隐式原型"}},[_._v("#")]),_._v(" 显式原型和隐式原型")]),_._v(" "),t("ul",[t("li",[_._v("每个函数对象都有一个 prototype 属性，称为显式原型属性，默认指向"),t("code",[_._v("{}")]),_._v("空实例对象。")]),_._v(" "),t("li",[_._v("每个实例对象都有一个"),t("strong",[_._v("proto")]),_._v("属性，称为隐式原型属性。")]),_._v(" "),t("li",[_._v("构造函数对象的显示原型===实例对象的隐式原型\n"),t("ul",[t("li",[_._v("Function 是 new Function()产生的")]),_._v(" "),t("li",[_._v("Object 也是 new Function()产生的")])])]),_._v(" "),t("li",[_._v("所有函数的"),t("strong",[_._v("proto")]),_._v("都是一样的")]),_._v(" "),t("li",[_._v("函数的 prototype 属性：在定义函数时自动添加的，默认值是 Object 空对象。")]),_._v(" "),t("li",[_._v("对象的"),t("strong",[_._v("proto")]),_._v("属性：创建对象时自动添加的，默认值为构造函数的 prototype 属性值。")]),_._v(" "),t("li",[_._v("不要直接操作隐式原型(ES6 之前)。")])]),_._v(" "),t("h3",{attrs:{id:"原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[_._v("#")]),_._v(" 原型链")]),_._v(" "),t("ul",[t("li",[_._v("访问一个对象的属性，先在自身寻找，找到返回")]),_._v(" "),t("li",[_._v("找不到沿着"),t("strong",[_._v("proto")]),_._v("这条链找，找到返回")]),_._v(" "),t("li",[_._v("最终没找到，返回 undefined")]),_._v(" "),t("li",[_._v("原型链别名隐式原型链")])]),_._v(" "),t("p",[_._v("作用：查找对象属性（方法）")]),_._v(" "),t("h3",{attrs:{id:"原型的继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型的继承"}},[_._v("#")]),_._v(" 原型的继承")]),_._v(" "),t("ul",[t("li",[_._v("构造函数的实例对象自动拥有构造函数原型对象的属性（方法）")]),_._v(" "),t("li",[_._v("原理：原型链")])]),_._v(" "),t("ol",[t("li",[_._v("所有函数的显示原型指向的对象是空 Object 实例对象(Object 不满足)\n"),t("ul",[t("li",[t("code",[_._v("Object.prototype instanceof Object")]),_._v("//false")])])]),_._v(" "),t("li",[_._v("所有函数都是 Function 的实例，包括 Function 本身和 Object\n"),t("ul",[t("li",[t("code",[_._v("Function.__proto__===Function.prototype")])])])]),_._v(" "),t("li",[_._v("Object 的原型对象是原型链的尽头\n"),t("ul",[t("li",[t("code",[_._v("object.prototype.__proto__")]),_._v("//null")])])])]),_._v(" "),t("h3",{attrs:{id:"instanceof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#instanceof"}},[_._v("#")]),_._v(" instanceof")]),_._v(" "),t("ul",[t("li",[_._v("A instanceof B")]),_._v(" "),t("li",[_._v("如果 B 函数的显式原型对象在 A 对象的原型链上，返回 true，否则返回 false。")])]),_._v(" "),t("h2",{attrs:{id:"回调函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[_._v("#")]),_._v(" 回调函数")]),_._v(" "),t("p",[_._v("什么是回调函数？")]),_._v(" "),t("ul",[t("li",[_._v("你定义的")]),_._v(" "),t("li",[_._v("你没有调用")]),_._v(" "),t("li",[_._v("但最终函数执行了")])]),_._v(" "),t("p",[_._v("常见的回调函数？")]),_._v(" "),t("ul",[t("li",[_._v("DOM 事件的回调函数")]),_._v(" "),t("li",[_._v("定时器回调函数")]),_._v(" "),t("li",[_._v("Ajax 请求回调函数")]),_._v(" "),t("li",[_._v("生命周期回调函数")])]),_._v(" "),t("h2",{attrs:{id:"iife"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iife"}},[_._v("#")]),_._v(" IIFE")]),_._v(" "),t("p",[_._v("IIFE；Immediately-Invoked Function Expression（立即调用的函数表达式），也称为"),t("code",[_._v("匿名函数自调用")])]),_._v(" "),t("p",[_._v("使用 IIFE 的好处：")]),_._v(" "),t("ul",[t("li",[_._v("不必为函数命名，避免了污染全局变量")]),_._v(" "),t("li",[_._v("IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。")])]),_._v(" "),t("h2",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[_._v("#")]),_._v(" this")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("fun()")]),_._v("this 是 window")]),_._v(" "),t("li",[t("code",[_._v("obj.fun()")]),_._v("this 是 obj")]),_._v(" "),t("li",[t("code",[_._v("var p = new test()")]),_._v("this 是新建的对象 p")]),_._v(" "),t("li",[t("code",[_._v("p.call(obj)")]),_._v("this 是 obj")])]),_._v(" "),t("h2",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[_._v("#")]),_._v(" 闭包")]),_._v(" "),t("p",[_._v("闭包产生的条件：")]),_._v(" "),t("ul",[t("li",[_._v("函数嵌套。")]),_._v(" "),t("li",[_._v("内部函数引用了外部函数的数据（变量/函数）")])]),_._v(" "),t("p",[_._v("通过 chrome 调试工具可以查看闭包")]),_._v(" "),t("ul",[t("li",[_._v("闭包是一种函数，闭包是一种现象。")])]),_._v(" "),t("h3",{attrs:{id:"常见的闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的闭包"}},[_._v("#")]),_._v(" 常见的闭包")]),_._v(" "),t("ol",[t("li",[_._v("将一个函数作为另一个函数的返回值")]),_._v(" "),t("li",[_._v("将函数作为实参传递给另一个函数")])]),_._v(" "),t("h3",{attrs:{id:"闭包的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包的作用"}},[_._v("#")]),_._v(" 闭包的作用")]),_._v(" "),t("ul",[t("li",[_._v("函数执行完后，延长变量的生命周期")]),_._v(" "),t("li",[_._v("让函数外部可以操作内部的数据变量")]),_._v(" "),t("li",[_._v("在函数执行完后，函数内部的局部变量一般不会存在，除了闭包中的变量。")]),_._v(" "),t("li",[_._v("函数外部不能访问函数内部的局部变量，但可以通过闭包让外部来操作内部的局部变量。")])]),_._v(" "),t("h3",{attrs:{id:"闭包的产生和死亡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包的产生和死亡"}},[_._v("#")]),_._v(" 闭包的产生和死亡")]),_._v(" "),t("ul",[t("li",[_._v("在嵌套内部函数时就产生了（不是调用）")]),_._v(" "),t("li",[_._v("在嵌套的内部函数成为垃圾对象时死亡 f=null")])]),_._v(" "),t("h3",{attrs:{id:"闭包的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包的应用"}},[_._v("#")]),_._v(" 闭包的应用")]),_._v(" "),t("p",[_._v("定义 JS 模块")]),_._v(" "),t("ul",[t("li",[_._v("具有特定功能的 JS 文件")]),_._v(" "),t("li",[_._v("将所有数据和功能都封装到一个函数内部（私有的）")]),_._v(" "),t("li",[_._v("只向外暴露一个包含 n 个方法的对象和函数")]),_._v(" "),t("li",[_._v("模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能")])]),_._v(" "),t("p",[_._v("如何向外暴露方法：通过 return 或者在函数内部添加 window 的方法")]),_._v(" "),t("h3",{attrs:{id:"闭包的的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包的的缺点"}},[_._v("#")]),_._v(" 闭包的的缺点")]),_._v(" "),t("ul",[t("li",[_._v("函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。")]),_._v(" "),t("li",[_._v("要即使释放"),t("code",[_._v("f = null")])])]),_._v(" "),t("h3",{attrs:{id:"内存溢出和内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出和内存泄漏"}},[_._v("#")]),_._v(" 内存溢出和内存泄漏")]),_._v(" "),t("p",[_._v("内存溢出：")]),_._v(" "),t("ul",[t("li",[_._v("当程序运行所需的内存超过了剩余的内存，就会抛出内存溢出错误")])]),_._v(" "),t("p",[_._v("内存泄漏：")]),_._v(" "),t("ul",[t("li",[_._v("内存泄露指用不到（访问不到）的变量，依然占据这内存空间，不能被再次利用。")]),_._v(" "),t("li",[_._v("占用的内存没有及时释放")]),_._v(" "),t("li",[_._v("内存泄漏过多就会导致内存溢出")])]),_._v(" "),t("p",[_._v("常见的内存泄漏：")]),_._v(" "),t("ul",[t("li",[_._v("意外的全局变量")]),_._v(" "),t("li",[_._v("没有及时清理的计时器或回调函数")]),_._v(" "),t("li",[_._v("不合理的使用闭包会导致内存泄漏")])])])}),[],!1,null,null,null);v.default=i.exports}}]);