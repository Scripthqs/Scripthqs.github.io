(window.webpackJsonp=window.webpackJsonp||[]).push([[248],{720:function(t,v,_){"use strict";_.r(v);var s=_(21),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"let-和-const"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const"}},[t._v("#")]),t._v(" Let 和 const")]),t._v(" "),_("p",[t._v("var 的设计可以看作成 JavaScript 语言设计的缺陷。使用 let 替代 var 可以解决没有块级作用域的问题。")]),t._v(" "),_("h2",{attrs:{id:"块级作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[t._v("#")]),t._v(" 块级作用域")]),t._v(" "),_("p",[t._v("块级作用域"),_("code",[t._v("{}")]),t._v("里面声明的变量不会被外面访问。在 ES5 之前，if 和 for 都没有块级作用域，必须借助函数作用域。")]),t._v(" "),_("h2",{attrs:{id:"let-声明变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#let-声明变量"}},[t._v("#")]),t._v(" let 声明变量")]),t._v(" "),_("ol",[_("li",[t._v("let 变量不能重复声明")]),t._v(" "),_("li",[t._v("有块级作用域")]),t._v(" "),_("li",[t._v("不存在变量提升")]),t._v(" "),_("li",[t._v("不影响作用域链")]),t._v(" "),_("li",[t._v("声明的变量不再是 window 的属性")])]),t._v(" "),_("p",[_("strong",[t._v("应用场景：以后声明变量使用 let 就对了")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"const-声明常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#const-声明常量"}},[t._v("#")]),t._v(" const 声明常量")]),t._v(" "),_("ol",[_("li",[t._v("一定要赋初值")]),t._v(" "),_("li",[t._v("常量的值不能修改")]),t._v(" "),_("li",[t._v("一般常量使用大写")]),t._v(" "),_("li",[t._v("有块级作用域")]),t._v(" "),_("li",[t._v("声明的变量不再是 window 的属性")])]),t._v(" "),_("p",[t._v("对于数组和对象中的元素修改，不算对常量的修改，不会报错，使用 const 声明数组和对象比较稳妥，考虑优先使用")]),t._v(" "),_("p",[_("strong",[t._v("注意: 对象属性修改和数组元素变化不会出发 const 错误")]),t._v("。")]),t._v(" "),_("p",[_("strong",[t._v("应用场景：声明对象类型使用 const，非对象类型声明选择 let")]),t._v("。")])])}),[],!1,null,null,null);v.default=a.exports}}]);