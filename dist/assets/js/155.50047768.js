(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{604:function(v,_,e){"use strict";e.r(_);var t=e(50),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"回流-reflow-与重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow-与重绘-repaint"}},[v._v("#")]),v._v(" 回流(reflow)与重绘(repaint)")]),v._v(" "),e("h2",{attrs:{id:"_1-浏览器的渲染机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器的渲染机制"}},[v._v("#")]),v._v(" 1 浏览器的渲染机制")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("浏览器会把HTML解析成DOM")])]),v._v(" "),e("li",[e("p",[v._v("把CSS解析成CSSOM")])]),v._v(" "),e("li",[e("p",[v._v("DOM和CSSOM合并就产生了渲染树（Render Tree）")])]),v._v(" "),e("li",[e("p",[v._v("有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。")])]),v._v(" "),e("li",[e("p",[v._v("对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一")])])]),v._v(" "),e("h2",{attrs:{id:"_2-重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-重绘-repaint"}},[v._v("#")]),v._v(" 2 重绘(repaint)")]),v._v(" "),e("p",[v._v("当页面中"),e("strong",[v._v("元素样式的改变")]),v._v("并"),e("strong",[v._v("不影响它在文档流中的位置")]),v._v("时（例如："),e("code",[v._v("color")]),v._v("、"),e("code",[v._v("background-color")]),v._v("、"),e("code",[v._v("visibility")]),v._v("等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),v._v(" "),e("p",[e("strong",[v._v("不影响布局即是重绘。")])]),v._v(" "),e("h2",{attrs:{id:"_3-回流-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-回流-reflow"}},[v._v("#")]),v._v(" 3 回流(reflow)")]),v._v(" "),e("p",[v._v("当"),e("code",[v._v("Render Tree")]),v._v("中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。")]),v._v(" "),e("ul",[e("li",[v._v("页面首次渲染")]),v._v(" "),e("li",[v._v("浏览器窗口大小发生改变")]),v._v(" "),e("li",[v._v("元素尺寸或位置发生改变")]),v._v(" "),e("li",[v._v("元素内容变化（文字数量或图片大小等等）")]),v._v(" "),e("li",[v._v("元素字体大小变化")]),v._v(" "),e("li",[v._v("添加或者删除"),e("strong",[v._v("可见")]),v._v("的"),e("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),e("li",[v._v("激活"),e("code",[v._v("CSS")]),v._v("伪类（例如："),e("code",[v._v(":hover")]),v._v("）")]),v._v(" "),e("li",[v._v("查询某些属性或调用某些方法")])]),v._v(" "),e("p",[v._v("一些常用且会导致回流的属性和方法：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("clientWidth")]),v._v("、"),e("code",[v._v("clientHeight")]),v._v("、"),e("code",[v._v("clientTop")]),v._v("、"),e("code",[v._v("clientLeft")])]),v._v(" "),e("li",[e("code",[v._v("offsetWidth")]),v._v("、"),e("code",[v._v("offsetHeight")]),v._v("、"),e("code",[v._v("offsetTop")]),v._v("、"),e("code",[v._v("offsetLeft")])]),v._v(" "),e("li",[e("code",[v._v("scrollWidth")]),v._v("、"),e("code",[v._v("scrollHeight")]),v._v("、"),e("code",[v._v("scrollTop")]),v._v("、"),e("code",[v._v("scrollLeft")])]),v._v(" "),e("li",[e("code",[v._v("scrollIntoView()")]),v._v("、"),e("code",[v._v("scrollIntoViewIfNeeded()")])]),v._v(" "),e("li",[e("code",[v._v("getComputedStyle()")])]),v._v(" "),e("li",[e("code",[v._v("getBoundingClientRect()")])]),v._v(" "),e("li",[e("code",[v._v("scrollTo()")])])]),v._v(" "),e("p",[e("strong",[v._v("影响了布局就会回流")])]),v._v(" "),e("p",[e("strong",[v._v("回流必定会发生重绘，重绘不一定会引发回流。")])]),v._v(" "),e("p",[e("strong",[v._v("回流比重绘的代价要更高。")])]),v._v(" "),e("h2",{attrs:{id:"_4-display-none和visibility-hidden"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-display-none和visibility-hidden"}},[v._v("#")]),v._v(" 4 display: none和visibility:hidden")]),v._v(" "),e("p",[v._v("共同点：都可以让元素变得不可见")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("display:none，该元素不占据任何空间，在文档渲染时，该元素如同不存在。非继承属性。")])]),v._v(" "),e("li",[e("p",[v._v("visibility:hidden，该元素空间依旧存在。继承属性，子孙节点继承hidden，可以设置visible来显示。")])]),v._v(" "),e("li",[e("p",[v._v("display:none，会触发reflow（回流），所以必然repaint（重绘）进行渲染")])]),v._v(" "),e("li",[e("p",[v._v("visibility:hidden，只会触发repaint（重绘），因为没有发生位置变化，不进行渲染。")])])]),v._v(" "),e("h2",{attrs:{id:"_5-如何避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何避免"}},[v._v("#")]),v._v(" 5.如何避免")]),v._v(" "),e("h3",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[v._v("#")]),v._v(" CSS")]),v._v(" "),e("ul",[e("li",[v._v("避免使用"),e("code",[v._v("table")]),v._v("布局。")]),v._v(" "),e("li",[v._v("尽可能在"),e("code",[v._v("DOM")]),v._v("树的最末端改变"),e("code",[v._v("class")]),v._v("。")]),v._v(" "),e("li",[v._v("避免设置多层内联样式。")]),v._v(" "),e("li",[v._v("将动画效果应用到"),e("code",[v._v("position")]),v._v("属性为"),e("code",[v._v("absolute")]),v._v("或"),e("code",[v._v("fixed")]),v._v("的元素上。")]),v._v(" "),e("li",[v._v("避免使用"),e("code",[v._v("CSS")]),v._v("表达式（例如："),e("code",[v._v("calc()")]),v._v("）。")])]),v._v(" "),e("h3",{attrs:{id:"javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[v._v("#")]),v._v(" JavaScript")]),v._v(" "),e("ul",[e("li",[v._v("避免频繁操作样式，最好一次性重写"),e("code",[v._v("style")]),v._v("属性，或者将样式列表定义为"),e("code",[v._v("class")]),v._v("并一次性更改"),e("code",[v._v("class")]),v._v("属性。")]),v._v(" "),e("li",[v._v("避免频繁操作"),e("code",[v._v("DOM")]),v._v("，创建一个"),e("code",[v._v("documentFragment")]),v._v("，在它上面应用所有"),e("code",[v._v("DOM操作")]),v._v("，最后再把它添加到文档中。")]),v._v(" "),e("li",[v._v("也可以先为元素设置"),e("code",[v._v("display: none")]),v._v("，操作结束后再把它显示出来。因为在"),e("code",[v._v("display")]),v._v("属性为"),e("code",[v._v("none")]),v._v("的元素上进行的"),e("code",[v._v("DOM")]),v._v("操作不会引发回流和重绘。")]),v._v(" "),e("li",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),v._v(" "),e("li",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])])])}),[],!1,null,null,null);_.default=i.exports}}]);