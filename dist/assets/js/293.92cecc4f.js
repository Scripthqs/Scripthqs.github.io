(window.webpackJsonp=window.webpackJsonp||[]).push([[293],{762:function(v,_,e){"use strict";e.r(_);var t=e(21),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理"}},[v._v("#")]),v._v(" 浏览器原理")]),v._v(" "),e("p",[v._v("浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列的渲染任务，开启渲染流程。")]),v._v(" "),e("h2",{attrs:{id:"浏览器渲染机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[v._v("#")]),v._v(" 浏览器渲染机制")]),v._v(" "),e("p",[v._v("浏览器渲染网页分为以下步骤：")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("解析 HTML(parse HTML)")]),v._v(" "),e("ul",[e("li",[v._v("默认情况下服务器会给浏览器返回 index.html 文件，解析 HTML 是所有步骤的开始")]),v._v(" "),e("li",[v._v("解析 HTML，会构建 DOM Tree")])])]),v._v(" "),e("li",[e("p",[v._v("生成 CSS 规则")]),v._v(" "),e("ul",[e("li",[v._v("遇到 CSS 的 link 元素，那么会由浏览器负责下载对应的 CSS 文件")]),v._v(" "),e("li",[v._v("下载 CSS 文件不会影响 DOM 的解析的")]),v._v(" "),e("li",[v._v("浏览器下载完 CSS 文件后，就会对 CSS 文件进行解析，解析出对应的规则树")]),v._v(" "),e("li",[v._v("该规则树可称为 CSSOM（CSS Object Model，CSS 对象模型）")])])]),v._v(" "),e("li",[e("p",[v._v("构建 Render Tree")]),v._v(" "),e("ul",[e("li",[v._v("当有了 DOM Tree 和 CSSOM Tree 后，就可以两个结合来构建 Render Tree")]),v._v(" "),e("li",[v._v("link 元素不会阻塞 DOM Tree 的构建过程，但是会阻塞 Render Tree 的构建过程")]),v._v(" "),e("li",[v._v("Render Tree 和 DOM Tree 并不是一一对应的关系，比如对于 display 为 none 的元素，就不会出现在 render tree 中")])])]),v._v(" "),e("li",[e("p",[v._v("布局（layout）和绘制（Paint）")]),v._v(" "),e("ul",[e("li",[v._v("有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，开始布局，把节点绘制到页面上。")]),v._v(" "),e("li",[v._v("对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一")])])])]),v._v(" "),e("p",[v._v("HTML 字符串-> 解析 HTML -> 样式计算 -> 布局 -> 分层 -> 绘制 -> 分块 -> 光栅化 -> 画 -> 像素信息")]),v._v(" "),e("h3",{attrs:{id:"回流-reflow-与重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow-与重绘-repaint"}},[v._v("#")]),v._v(" 回流 reflow 与重绘 repaint")]),v._v(" "),e("p",[v._v("重绘 repaint")]),v._v(" "),e("p",[v._v("浏览器第一次渲染叫做绘制，重新渲染就叫做重绘。例如当页面中"),e("strong",[v._v("元素样式的改变")]),v._v("并"),e("strong",[v._v("不影响它在文档流中的位置")]),v._v("时（例如："),e("code",[v._v("color")]),v._v("、"),e("code",[v._v("background-color")]),v._v("、"),e("code",[v._v("visibility")]),v._v("等），浏览器会将新样式赋予给元素并重新绘制。")]),v._v(" "),e("p",[e("strong",[v._v("不影响布局即是重绘。")])]),v._v(" "),e("p",[v._v("回流 reflow")]),v._v(" "),e("p",[v._v("第一次确定节点的大小和位置，称之为布局（layout）。之后对节点的大小、位置修改重新计算称之为回流。")]),v._v(" "),e("p",[v._v("当"),e("code",[v._v("Render Tree")]),v._v("中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程就是回流。")]),v._v(" "),e("ul",[e("li",[v._v("如 DOM 结构发生改变（添加新的节点或者移除节点）")]),v._v(" "),e("li",[v._v("浏览器窗口大小发生改变")]),v._v(" "),e("li",[v._v("元素尺寸或位置发生改变")]),v._v(" "),e("li",[v._v("元素内容变化（文字数量或图片大小等等）")]),v._v(" "),e("li",[v._v("元素字体大小变化")]),v._v(" "),e("li",[v._v("添加或者删除"),e("strong",[v._v("可见")]),v._v("的"),e("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),e("li",[v._v("激活"),e("code",[v._v("CSS")]),v._v("伪类（例如："),e("code",[v._v(":hover")]),v._v("）")]),v._v(" "),e("li",[v._v("查询某些属性或调用某些方法，例如调用 getComputedStyle 方法获取尺寸、位置信息")])]),v._v(" "),e("p",[v._v("一些常用且会导致回流的属性和方法：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("clientWidth")]),v._v("、"),e("code",[v._v("clientHeight")]),v._v("、"),e("code",[v._v("clientTop")]),v._v("、"),e("code",[v._v("clientLeft")])]),v._v(" "),e("li",[e("code",[v._v("offsetWidth")]),v._v("、"),e("code",[v._v("offsetHeight")]),v._v("、"),e("code",[v._v("offsetTop")]),v._v("、"),e("code",[v._v("offsetLeft")])]),v._v(" "),e("li",[e("code",[v._v("scrollWidth")]),v._v("、"),e("code",[v._v("scrollHeight")]),v._v("、"),e("code",[v._v("scrollTop")]),v._v("、"),e("code",[v._v("scrollLeft")])]),v._v(" "),e("li",[e("code",[v._v("scrollIntoView()")]),v._v("、"),e("code",[v._v("scrollIntoViewIfNeeded()")])]),v._v(" "),e("li",[e("code",[v._v("getComputedStyle()")])]),v._v(" "),e("li",[e("code",[v._v("getBoundingClientRect()")])]),v._v(" "),e("li",[e("code",[v._v("scrollTo()")])])]),v._v(" "),e("p",[v._v("影响了"),e("strong",[v._v("布局就会回流")])]),v._v(" "),e("p",[e("strong",[v._v("回流必定会发生重绘")]),v._v("，重绘不一定会引发回流。")]),v._v(" "),e("p",[e("strong",[v._v("回流比重绘的代价要更高。")])]),v._v(" "),e("p",[v._v("display: none 和 visibility:hidden 比较")]),v._v(" "),e("p",[v._v("共同点：都可以让元素变得不可见")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("display:none，该元素不占据任何空间，在文档渲染时，该元素如同不存在。非继承属性。")])]),v._v(" "),e("li",[e("p",[v._v("visibility:hidden，该元素空间依旧存在。继承属性，子孙节点继承 hidden，可以设置 visible 来显示。")])]),v._v(" "),e("li",[e("p",[v._v("display:none，会触发 reflow（回流），所以必然 repaint（重绘）进行渲染")])]),v._v(" "),e("li",[e("p",[v._v("visibility:hidden，只会触发 repaint（重绘），因为没有发生位置变化，不进行渲染。")])])]),v._v(" "),e("p",[v._v("可以通过 css 和 js 相关")]),v._v(" "),e("p",[v._v("CSS")]),v._v(" "),e("ul",[e("li",[v._v("避免使用"),e("code",[v._v("table")]),v._v("布局。")]),v._v(" "),e("li",[v._v("尽可能在"),e("code",[v._v("DOM")]),v._v("树的最末端改变"),e("code",[v._v("class")]),v._v("。")]),v._v(" "),e("li",[v._v("避免设置多层内联样式。")]),v._v(" "),e("li",[v._v("将动画效果应用到"),e("code",[v._v("position")]),v._v("属性为"),e("code",[v._v("absolute")]),v._v("或"),e("code",[v._v("fixed")]),v._v("的元素上。")]),v._v(" "),e("li",[v._v("避免使用"),e("code",[v._v("CSS")]),v._v("表达式（例如："),e("code",[v._v("calc()")]),v._v("）。")])]),v._v(" "),e("p",[v._v("JavaScript")]),v._v(" "),e("ul",[e("li",[v._v("避免频繁操作样式，最好一次性重写"),e("code",[v._v("style")]),v._v("属性，或者将样式列表定义为"),e("code",[v._v("class")]),v._v("并一次性更改"),e("code",[v._v("class")]),v._v("属性。")]),v._v(" "),e("li",[v._v("避免频繁操作"),e("code",[v._v("DOM")]),v._v("，创建一个"),e("code",[v._v("documentFragment")]),v._v("，在它上面应用所有"),e("code",[v._v("DOM操作")]),v._v("，最后再把它添加到文档中。")]),v._v(" "),e("li",[v._v("也可以先为元素设置"),e("code",[v._v("display: none")]),v._v("，操作结束后再把它显示出来。因为在"),e("code",[v._v("display")]),v._v("属性为"),e("code",[v._v("none")]),v._v("的元素上进行的"),e("code",[v._v("DOM")]),v._v("操作不会引发回流和重绘。")]),v._v(" "),e("li",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),v._v(" "),e("li",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])]),v._v(" "),e("h3",{attrs:{id:"composite-合成-web-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#composite-合成-web-优化"}},[v._v("#")]),v._v(" composite 合成（web 优化）")]),v._v(" "),e("p",[v._v("默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中。浏览器有一种优化手段，在绘制的过程，可以将布局后的元素绘制到多个合成图层中。")]),v._v(" "),e("p",[v._v("有一些特殊的属性，会创建一个新的合成层（ CompositingLayer ），并且新的图层可以利用 GPU 来加速绘制，每个合成层都是单独渲染的，以下属性可以生成新的合成层。")]),v._v(" "),e("ul",[e("li",[v._v("3D transforms")]),v._v(" "),e("li",[v._v("video、canvas、iframe")]),v._v(" "),e("li",[v._v("opacity 动画转换时")]),v._v(" "),e("li",[v._v("position: fixed")]),v._v(" "),e("li",[v._v("will-change：一个实验性的属性，提前告诉浏览器元素可能发生哪些变化")]),v._v(" "),e("li",[v._v("animation 或 transition 设置了 opacity、transform；")])]),v._v(" "),e("p",[v._v("分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。")]),v._v(" "),e("p",[v._v("谷歌浏览器工具里可以看到这个 layer。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/scripthqs/assets/master/blog/css_layers.png",alt:"layer工具"}})]),v._v(" "),e("h3",{attrs:{id:"script-元素和页面解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#script-元素和页面解析"}},[v._v("#")]),v._v(" script 元素和页面解析")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("浏览器在解析 HTML 的过程中，遇到了 script 元素是不能继续构建 DOM 树的；")])]),v._v(" "),e("li",[e("p",[v._v("它会停止继续构建，首先下载 JavaScript 代码，并且执行 JavaScript 的脚本；")])]),v._v(" "),e("li",[e("p",[v._v("只有等到 JavaScript 脚本执行结束后，才会继续解析 HTML，构建 DOM 树；")])])]),v._v(" "),e("p",[v._v("为什么要先等到 js 脚本结束后才能继续解析，或者说为什么要这么设计")]),v._v(" "),e("ul",[e("li",[v._v("JavaScript 的作用之一就是操作 DOM，并且可以修改 DOM")]),v._v(" "),e("li",[v._v("等到 DOM 树构建完成并且渲染再执行 JavaScript，会造成严重的回流和重绘，影响页面的性能；")]),v._v(" "),e("li",[v._v("因此遇到 script 元素时，优先下载和执行 JavaScript 代码，再继续构建 DOM 树")])]),v._v(" "),e("p",[v._v("但是，在目前的开发模式中（比如 Vue、React），脚本往往比 HTML 页面更“重”，处理时间需要更长；")]),v._v(" "),e("ul",[e("li",[v._v("会造成页面的解析阻塞，在脚本下载、执行完成之前，用户在界面上什么都看不到")]),v._v(" "),e("li",[v._v("为了解决这个问题，script 元素给我们提供了两个属性（attribute）：defer 和 async")])]),v._v(" "),e("h3",{attrs:{id:"defer-属性和-async-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#defer-属性和-async-属性"}},[v._v("#")]),v._v(" defer 属性和 async 属性")]),v._v(" "),e("p",[v._v("defer 属性告诉浏览器不要等待脚本下载，而继续解析 HTML，构建 DOM Tree。")]),v._v(" "),e("ul",[e("li",[v._v("加上 defer 后，js 的下载和执行，不会阻塞 DOM Tree 的构建过程")]),v._v(" "),e("li",[v._v("在 defer 的 js 文件中，是可以去操作 DOM Tree 的")]),v._v(" "),e("li",[v._v("defer 的 js 文件是在 DOMContentLoaded 事件之前先执行的")]),v._v(" "),e("li",[v._v("多个带 defer 的脚本是可以保持正确的顺序执行的")]),v._v(" "),e("li",[v._v("defer 可以提高页面的性能，并且推荐放到 head 元素中")]),v._v(" "),e("li",[v._v("defer 仅适用于外部引用脚本，对于 script 默认内容会被忽略，加了也没有用。")])]),v._v(" "),e("p",[v._v("async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。可以让脚本完全独立。")]),v._v(" "),e("ul",[e("li",[v._v("浏览器不会因 async 脚本而阻塞（与 defer 类似）")]),v._v(" "),e("li",[v._v("async 脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本")]),v._v(" "),e("li",[v._v("async 不会能保证在 DOMContentLoaded 之前或者之后执行")])]),v._v(" "),e("p",[v._v("区别：")]),v._v(" "),e("ul",[e("li",[v._v("defer 通常用于需要在文档解析后操作 DOM 的 JavaScript 代码，并且对多个 script 文件有顺序要求的")]),v._v(" "),e("li",[v._v("async 通常用于独立的脚本，对其他脚本，甚至 DOM 没有依赖的；")])]),v._v(" "),e("h2",{attrs:{id:"浏览器的-js-引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的-js-引擎"}},[v._v("#")]),v._v(" 浏览器的 Js 引擎")]),v._v(" "),e("p",[v._v("浏览器内核是由两部分组成的，以 webkit 中分为")]),v._v(" "),e("ul",[e("li",[v._v("WebCore：负责 HTML 解析、布局、渲染等等相关的工作；")]),v._v(" "),e("li",[v._v("JavaScriptCore：解析、执行 JavaScript 代码；")])]),v._v(" "),e("h3",{attrs:{id:"v8-引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎"}},[v._v("#")]),v._v(" V8 引擎")]),v._v(" "),e("p",[v._v("目前最强大的 js 引擎就是 V8 引擎。")]),v._v(" "),e("p",[v._v("V8 是用 C ++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，它用于 Chrome 和 Node.js。")]),v._v(" "),e("ul",[e("li",[v._v("V8 可以独立运行，也可以嵌入到任何 C ++应用程序中")])]),v._v(" "),e("p",[v._v("代码交给 CPU 执行，源代码转成二进制代码，才能被 CPU 执行，V8 引擎的作用就是将源代码转成二进制代码。")]),v._v(" "),e("p",[v._v("V8 引擎有几个重要的模块：")]),v._v(" "),e("ul",[e("li",[v._v("Parse 模块会将 JavaScript 代码转换成 AST（抽象语法树）")]),v._v(" "),e("li",[v._v("Ignition 是一个解释器，会将 AST 转换成 ByteCode（字节码）")]),v._v(" "),e("li",[v._v("TurboFan 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码")])]),v._v(" "),e("h3",{attrs:{id:"js-的执行原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-的执行原理"}},[v._v("#")]),v._v(" Js 的执行原理")]),v._v(" "),e("ul",[e("li",[v._v("ES3 的主要概念包括 JavaScript 执行原理、作用域、作用域链、闭包。")]),v._v(" "),e("li",[v._v("ES5 中的概念包括块级作用域、let、const 等；")])]),v._v(" "),e("h3",{attrs:{id:"初始化全局对象-go"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化全局对象-go"}},[v._v("#")]),v._v(" 初始化全局对象(GO)")]),v._v(" "),e("p",[v._v("js 引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）")]),v._v(" "),e("ul",[e("li",[v._v("该对象的所有作用域(scope)都可以访问")]),v._v(" "),e("li",[v._v("里面包含了 Date、Array、String、Number、setTimeout、setInterval 等等")]),v._v(" "),e("li",[v._v("其中还有一个 window 属性指向自己")])]),v._v(" "),e("h3",{attrs:{id:"执行上下文-ecs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文-ecs"}},[v._v("#")]),v._v(" 执行上下文(ECS)")]),v._v(" "),e("ul",[e("li",[v._v("js 引擎内部有一个执行上下文栈(Execution Context Stack，简称 ECS)，它是用于执行代码的调用栈。")]),v._v(" "),e("li",[v._v("全局的代码块为了执行会构建一个 Global Execution Context(GEC)")]),v._v(" "),e("li",[v._v("GEC 会被放入到 ECS 中执行；")])]),v._v(" "),e("p",[v._v("分为 2 步：")]),v._v(" "),e("ol",[e("li",[v._v("在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是并不会\n赋值；这个过程也称之为变量的作用域提升(hoisting)")]),v._v(" "),e("li",[v._v("在代码执行中，对变量赋值，或者执行其他的函数；")])]),v._v(" "),e("h3",{attrs:{id:"vo-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vo-对象"}},[v._v("#")]),v._v(" VO 对象")]),v._v(" "),e("ul",[e("li",[v._v("每一个执行上下文会关联一个 VO(Variable Object，变量对象)，变量和函数声明会被添加到这个 VO 对象中。")]),v._v(" "),e("li",[v._v("当全局代码被执行的时候，VO 就是 GO 对象了")])]),v._v(" "),e("h3",{attrs:{id:"函数执行上下文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数执行上下文"}},[v._v("#")]),v._v(" 函数执行上下文")]),v._v(" "),e("ul",[e("li",[v._v("在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文(Functional Execution Context，简称 FEC)，并且压入到 EC Stack 中。")]),v._v(" "),e("li",[v._v("因为每个执行上下文都会关联一个 VO，那么函数执行上下文关联的 VO 是什么呢")]),v._v(" "),e("li",[v._v("当进入一个函数执行上下文时，会创建一个 AO 对象（Activation Object）")]),v._v(" "),e("li",[v._v("这个 AO 对象会使用 arguments 作为初始化，并且初始值是传入的参数")]),v._v(" "),e("li",[v._v("这个 AO 对象会作为执行上下文的 VO 来存放变量的初始化")])]),v._v(" "),e("h3",{attrs:{id:"作用域和作用域链-scope-chain"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链-scope-chain"}},[v._v("#")]),v._v(" 作用域和作用域链（Scope Chain）")]),v._v(" "),e("p",[v._v("当进入到一个执行上下文时，执行上下文也会关联一个作用域链(Scope Chain)")]),v._v(" "),e("ul",[e("li",[v._v("作用域链是一个对象列表，用于变量标识符的求值")]),v._v(" "),e("li",[v._v("当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象")])])])}),[],!1,null,null,null);_.default=i.exports}}]);